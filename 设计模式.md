面向对象的封装、继承和多态三大特性是为了降低耦合性，从而实现程序的可维护（修改简单）、可复用、可扩展，并提高程序的灵活性。



#### 简单工厂模式 (Simple Factory)

在工厂类中创建实例对象，以多态的方式返回对象。工厂不一定要是一个单独的类，只是一种模式和思想。

#### 策略模式 (Strategy)

策略模式定义了算法族，可以随意进行使用算法的替换。只需要使用策略上下文来调用方法，选择需要使用的算法，实际用到的算法和抽象父类都不需要涉及到。该模式下可以结合简单工厂模式。

![策略模式UML](策略模式UML.png)

**策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。**

#### 装饰模式 (Decorator)

动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。

![装饰模式](C:\Users\Alan Ciao\Desktop\学习笔记\装饰模式.png)

#### 代理模式 (Proxy)

为其他对象提供一种代理以控制对这个对象的访问。

代理模式其实就在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。

![代理模式](C:\Users\Alan Ciao\Desktop\学习笔记\代理模式.png)

#### 工厂方法模式 (Factory Method)

定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

![工厂方法模式](C:\Users\Alan Ciao\Desktop\学习笔记\工厂方法模式.png)

工厂方法模式是对简单工厂的扩展，实现了开放-封闭原则，当需要扩展的时候，不需要再去修改工厂的内部代码，而是添加一个工厂的实现类来扩展现有的功能，通过子类工厂来替换父类（或接口）工厂。当需要某个对象时，只需要实例化对应的子类工厂即可，简化了对象创建的代码，提高扩展性。创建子类工厂的任务转移到了客户端，但是可以用反射的方法来实现最佳解决方案。

#### 原型模式 (Prototype)

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。

![原型模式](C:\Users\Alan Ciao\Desktop\学习笔记\原型模式.png)

#### 模板方法模式 (Template Method)

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。一般抽象类就是用来实现这种模板的父类。

模板方法模式提供了一个很好的代码复用平台，通过把不变的行为搬移到超类，去除子类中的重复代码来体现它的优势。

![模板方法模式](C:\Users\Alan Ciao\Desktop\学习笔记\模板方法模式.png)

#### 外观模式/门面模式 (Facade)

为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

![外观模式](C:\Users\Alan Ciao\Desktop\学习笔记\外观模式.png)

MVC 三层结构使用的就是门面模式，体现了依赖倒转原则和迪米特法则的思想，实现解耦和的作用。

#### 建造者模式

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。使用建造者模式，用户就只需要指定要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。在建造者模式中，建造的过程是稳定的，改变的只是具体的细节，过程的稳定可以使用抽象类来实现，具体细节放到子类中去实现。最后还需要指挥者 (Director) 类，接收抽象的过程类，然后调用相应的方法来完成流程建造，实现用户使用的隔离。很大部分的获得某个对象的功能都使用这种建造者模式。

![建造者模式](C:\Users\Alan Ciao\Desktop\学习笔记\建造者模式.png)

Builder 是为创建一个 Product 对象的各个部件指定的抽象接口。 ConcreteBuilder 是具体的建造者，实现 Builder 接口，构造和装配各个部件。 Product 就是具体的产品，而 Director 构建一个使用 Builder 接口的对象，用来建造产品。

建造者模式主要是用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。好处是使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了。

创造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。

#### 观察者模式 (Observer)

观察者模式也叫发布-订阅 (Publish/Subscribe) 模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

![观察者模式](C:\Users\Alan Ciao\Desktop\学习笔记\观察者模式.png)

将一个系统分割成一系列相互协作的类有一个很不好的副作用，就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合。观察者模式就是在解除耦合，让耦合的双方都依赖于抽象而不是依赖于具体，从而使得各自的变化都不会影响另一边的变化。

当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。

在观察者模式中，可以使用事件委托机制来调用处理方法。委托就是一种引用方法的类型，一旦为委托分配了方法，委托将与太方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值，委托可以看作是对函数的抽象，是函数的‘类’，委托的实例将代表一个具体的函数。（C#）

#### 抽象工厂模式 (Abstract Factory)

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

![抽象工厂模式](C:\Users\Alan Ciao\Desktop\学习笔记\抽象工厂模式.png)

抽象工厂包含抽象方法，需要生产一个抽象工厂的具体实现工厂，来生产需要的具体产品对象。

优点是易于交换产品系列，由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置。它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。换句话说，就是用接口引用实现类，达到解耦和的目的。

为了提高抽象工厂的功能，可以利用反射技术来加载不同的实现工厂类。这样就可以用一个简单工厂来取代抽象工厂类了。

#### 状态模式 (State)

当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况，把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。

![状态模式](C:\Users\Alan Ciao\Desktop\学习笔记\状态模式.png)

状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个 ConcreteState 中，所以通过定义新的子类可以很容易地增加新的状态和转换，这样做的目的就是为了消除庞大的条件分支语句。状态模式通过把各种状态转移逻辑分布到 State 的子类之间，来减少相互间的依赖。

当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式。

实现方法是创建一个 State 子类，当触发一个行为时，在子类状态中判断执行的行为内容，并设置状态的转换。

#### 适配器模式 (Adapter)

将一个类的接口转换成客户希望的另外一个接口。 Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

系统的数据和行为都正确，但接口不符时，我们应该考虑用配适器，目的是使控制范围之外的一个原有对象与某个接口匹配。配适器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。

![适配器模式](C:\Users\Alan Ciao\Desktop\学习笔记\适配器模式.png)

注意，配适器模式只在接口不一致且无法重构的情况下使用，如无需要不要随便使用该模式。

#### 备忘录模式 (Memento)

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。

![备忘录模式](C:\Users\Alan Ciao\Desktop\学习笔记\备忘录模式.png)

Memento 模式比较使用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时， Originator 可以根据保存的 Memento 信息还原到前一状态。如果再某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态。使用备忘录模式还可以把复杂的对象内部信息对其他的对象屏蔽起来，从而恰当地保持封装的边界。

#### 组合模式 (Composite)

将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。是合成/聚合复用原则的应用。

![组合模式](C:\Users\Alan Ciao\Desktop\学习笔记\组合模式.png)

当发现需求中是体现部分与整体层次的结构时，以及希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式了。通过组合模式定义的基本对象，可以组合成更复杂的组合对象，不断递归下去，形成树状层级结构。组合模式让客户可以一致地使用组合结构和单个对象。

#### 迭代器模式 (Iterator)

提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。

![迭代器模式](C:\Users\Alan Ciao\Desktop\学习笔记\迭代器模式.png)

#### 单例模式 (Singleton)

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

![单例模式](C:\Users\Alan Ciao\Desktop\学习笔记\单例模式.png)

单例模式因为 Singleton 类封装了它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。

#### 桥接模式 (Bridge)

将抽象部分与它的实现部分分离，使他们都可以独立地变化。实现指的是抽象类和它的派生类用来实现自己的对象。桥接模式的核心意图就是把一些实现独立出来，让它们各自地变化。这就使得每种实现的变化不会影响其他实现，从而达到应对变化的目的。

![桥接模式](C:\Users\Alan Ciao\Desktop\学习笔记\桥接模式.png)

换句话说，实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。

#### 命令模式 (Command)

将一个请求封装为一个对象，从而使你可用不同请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

![命令模式](C:\Users\Alan Ciao\Desktop\学习笔记\命令模式.png)

命令模式能较容易地设计一个命令队列；在需要的情况下，可以较容易地将命令计入日志；允许接收请求的一方决定是否要否决请求；可以容易地实现对请求的撤销和重做；由于加入新的具体命令类不影响其他的类，因此增加新的具体命令类很容易；命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。

只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义。

#### 职责链模式 (Chain of Responsibility)

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

![职责链模式](C:\Users\Alan Ciao\Desktop\学习笔记\职责链模式.png)

当客户提交一个请求时，请求时沿链传递直至有一个 ConcreteHandler 对象负责处理它。职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需要保持它所有的候选接受者的引用。可以随时地增加或修改处理一个请求的结构，增强了给对象指派职责的灵活性。

#### 中介者/调停者模式

是迪米特原则的应用。用一个中介对象来封装一系列的**对象交互**。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

![中介者模式](C:\Users\Alan Ciao\Desktop\学习笔记\中介者模式.png)

中介者模式很容易在系统中应用，也很容易在系统中误用。当系统出现了“多对多”交互复杂的对象群时，不要急于使用中介者模式，而要先反思你的系统在设计上是不是合理。优点是减少各个类之间的耦合，不需要直接通信，可以从宏观的角度来看待系统；缺点是将交互复杂性变为了中介者的复杂性，不容易维护。

中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。

#### 享元模式 (Flyweight)

运用共享技术有效地支持特大量细粒度的对象。

![享元模式](C:\Users\Alan Ciao\Desktop\学习笔记\享元模式.png)

享元模式可以避免大量非常相似类的开销（在相同需要的情况下，只生成一个共享实例）。在程序设计中，有时需要生成大量细粒度的类实例来表示数据，如果能发现这些实例除了几个参数外基本上都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。

如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；还有就是对象的大多数状态可以是外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。

字符串字面量就是一种享元模式， Servlet 也应该是一种享元模式， Spring 容器应该也是一种享元模式的体现。

#### 解释器模式 (Interpreter)

给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

正则表达式是解释器模式的一种应用。

![解释器模式](C:\Users\Alan Ciao\Desktop\学习笔记\解释器模式.png)

当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。解释器模式可以很容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可以使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写。

解释器模式就是对语法的一种解释功能，之所以用该模式是便于扩展和维护。

解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理。

#### 访问者模式 (Visitor)

表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变个元素的类的前提下定义作用于这些元素的新操作。

![访问者模式](C:\Users\Alan Ciao\Desktop\学习笔记\访问者模式.png)

访问者模式使用于数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。访问者模式的目的是要把处理从数据结构分离出来，如果系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较合适的，因为访问者模式使得算法操作的增加变得容易。访问者模式的优点就是增加新的操作很容易，只意味着增加一个新的访问者，该模式将有关的行为集中到一个访问者对象中。缺点就是使增加新的数据结构变得困难了。

简单来说，就是要处理的数据类型是稳定的，就那么几个类，但对这些数据的操作算法可能多种多样，变化比较距离，就可以采用访问者模式。顾名思义，算法就是一个访问者，它可以访问固定的数据结构并对数据进行操作，最终得出结果。新增算法结构时不会对稳定的数据结构造成影响。



#### 单一职责原则(SRP)

就一个类而言，应该仅有一个引起它变化的原因。

#### 开放-封闭原则(OCP)

软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。

#### 依赖倒转原则

高层模块不应该依赖低层模块，两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象（面向接口编程）。

依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。

#### 里氏代换原则(LSP)

一个软件实体如果使用的是一个父类的话，那么一定使用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。子类型必须能够替换掉它们的父类型。

这里体现了多态的应用。

#### 迪米特法则 (LoD 最少知识原则)

如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。也就是说，在类的结构设计上，每一个类都应当尽量降低成员的访问权限。根本思想是强调了类之间的松耦合，或者说信息的隐藏促进了软件的复用。

#### 合成/聚合复用原则 (CARP)

尽量使用合成/聚合，尽量不要使用类继承。聚合 (Aggregation) 表示一种弱的“拥有”关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分；合成 (Composition) 则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。

优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。