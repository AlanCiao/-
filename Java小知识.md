## Java 小知识

### Java字符串和常量池

今天遇到了一个很有意思的问题，见如下代码：

```java
public static void main(String[] args) {
  String str1 = new String("abc");
  System.out.println(str1 == str1.intern());
  
  String str2 = new String("java");
  System.out.println(str2 == str2.intern());
}
```

运行结果第一个是 `true` ，而第二个是 `false` 。这说明 `"java"` 这个字符串已经存在于 JVM 的常量池中了。

那么 Java 中的常量池到底是如何运作的呢？实际上，只有字符串字面值（就是直接用引号引起来的字符串）会被放入一个专门的存储区域，而用关键字 `new` 出来的字符串对象都存在于堆内存中，两者的地址值是不同的，因此比较引用时并不会相同。但是，当我们调用 `intern()` 方法时，首先 JVM 会在常量池中搜索是否存在这个字符串。如果存在，就直接返回该字符串的引用；如果不存在，就要把这个字符串存储到常量池中，但是，并不是直接把字符串常量写入常量池中，而是只存储该字符串的一个引用，所以新创建的 `String` 对象如果调用 `intern()` 方法，那么最终得到的引用是同一个，所以比较返回的是 `true` 。

其实，字符串 `java` 存在于常量池中也是很正常的一件事情，毕竟这是在运行 Java 程序嘛。



### JDBC

JDBC 4.0 以后强化了一个类 javax.sql.DataSource ，通过这个类同样可以加载数据库驱动，可以取代 DriverManager 方法，不需要注册驱动。

可以再研究和查看一下这方面的东西。



### 加载路径

ClassLoader 会从源文件路径开始查找，大概是因为 ClassLoader 就是从 src 下面开始加载的，所以最顶层的目录就是 src ，如果要查找 src 下面的文件的话，就需要相对于 src 为根目录来写目录。如果使用 InputStream 来读取文件的话，相对路径的根目录是相对于项目目录而言的，因为两者寻找父目录的方式是不一样的。



ClassLoader 是用来创建字节码文件 Class 示例对象的一个对象，也就是将字节码文件的信息和代码封装到一个 Class 对象中，供虚拟机调用。 ClassLoader 采用父子委托方式进行加载，以保证内存中同一个类只会加载一次。委托方式是指子级的类加载器加载字节码文件时，首先会把类加载的任务委托给父级类加载器处理，父级又会首先向父级的父级委托加载，当达到类加载器的最顶层时，会启动系统级 Bootstrap 类加载器来加载，如果找不到，则向下返回，由子级类加载器寻找，依次再向下传递。

Bootstrap 类加载器是系统底层的加载器，与系统有关，不是 Java 类，它负责加载 Java 的核心类库 rt.jar 。ExtClassLoader 负责加载扩展 Java 类库，位于 jre/lib/ext/ 目录下。AppClassLoader 负责加载应用中的 Java 类，即 ClassPath 中设置的路径，一般被称为系统类加载器。还可以有子类继承 AppClassLoader 完成自定义的类加载方式（一般还用不上）。实现时需要复写 findClass 方法而不是 loadClass 方法，这样还可以使用委托机制。

一个类中创建新的类的实例，默认用该类的加载器去加载新类。一般情况下，一个已被父级类加载器加载的类无法调用那些只能被子级类加载器发现和装载的其他类。在线程中，所有的类使用上下文类加载器，默认为父线程的上下文类加载器，而主线程默认的类加载器为系统（System）加载器。

Tomcat 启动后会将 ClassPath 变量清空，然后从新设置。网络应用会由自己特定的类加载器 WebappClassLoader 去加载，它寻找的路径是 WEB-INF/classes 。



### 编码

URLEncoder 编码是对网络上传递中文参数所进行的编码，本质上还是将字符按照相应的字符集转变成字节数组（Unicode -> UTF-8 等），只不过要对表示形式进行修改，如“中国”按 UTF-8 编码后会显示为 %E4%B8%AD%E5%9B%BD 。Java 之所以要使用 URL 编码是因为 Java 使用的是 Unicode 编码，在网络上传输时，需要将 Unicode 字符串中的特殊字符转换成非 Unicode 编码进行传输，这样不会造成解码错误。

BASE64Encoder 编码一般使用在需要加密的字符上，如认证用户名和密码。BASE64 就是一种将所有字符的字节编码转换成 ASCII 码形式的编码方式，这样可以将字节数据以 ASCII 码显示出来，不会对字节造成损失，在需要的时候还可以还原为相应的字节编码。

在 Java 程序中，所有编码转换在内存中都要变为 Unicode 编码。



#### Timestamp

MySQL 这个字段如果不赋值，那么就自动赋值当前时间